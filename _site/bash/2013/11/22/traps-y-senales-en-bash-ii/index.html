<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Traps y señales en bash (II)</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="b3V0IG9mIG1lbW9yeQ==">
    <link rel="canonical" href="http://localhost:4000/bash/2013/11/22/traps-y-senales-en-bash-ii/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">Out of memory</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Traps y señales en bash (II)</h1>
    <p class="meta">Nov 22, 2013</p>
  </header>

  <article class="post-content">
  <h1 id="traps-y-seales-en-bash-ii">Traps y señales en bash (II)</h1>

<p>Continuando con el artículo anterior, vamos a ver un ejemplo de cómo impedir la ejecución de varias instancias de un script.</p>

<p>Sea este complejísimo script, que cuenta de 1 en 1 hasta 10:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#!/bin/bash</span>
<span class="nv">i</span><span class="o">=</span>1
<span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
 <span class="nb">echo</span> <span class="nv">$i</span>
 <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
 sleep 1
<span class="k">done</span></code></pre></div>

<p>Evidentemente, no hay problema en ejecutarlo tantas veces como sea posible de forma concurrente. Por ejemplo:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>./nobloqueo.sh <span class="p">&amp;</span> ./nobloqueo.sh
<span class="o">[</span>1<span class="o">]</span> 19585
1
1
2
2
3
3
^C</code></pre></div>

<p>Uf, qué lío. Así no hay quien aprenda a contar. Sería mucho mejor impedir que el script se ejecutase más de una vez. Para ello, el método “clásico” es escribir un fichero de “lock”. Si el fichero existe, no me ejecuto; si no existe, lo escribo, me ejecuto, y lo borro después, para dejar que otro usuario pueda ejecutarlo. Hágase:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>cat bloqueo.sh
<span class="c">#!/bin/bash</span>
<span class="nv">LOCK</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">/bloqueo.lck&quot;</span>
<span class="c"># Si no existe el fichero, lo escribo y me ejecuto:</span>
<span class="k">if</span> <span class="o">[</span> ! -e <span class="nv">$LOCK</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
 touch <span class="nv">$LOCK</span>
 <span class="nv">i</span><span class="o">=</span>1
 <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
 <span class="nb">echo</span> <span class="nv">$i</span>
 <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
 sleep 1
 <span class="k">done</span>
 /bin/rm <span class="nv">$LOCK</span>
<span class="k">else</span>
 <span class="nb">echo</span> <span class="s2">&quot;Ya estoy contando hasta 10&quot;</span>
<span class="k">fi</span></code></pre></div>

<p>Si el fichero bloqueo.lck no existe, se creará y comenzará la cuenta; pero si existe dicho fichero, el script se quejará y no contará nada. Para probarlo, ejecuto el script en un terminal…</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>./bloqueo.sh
1
2
3</code></pre></div>

<p>y, mientras, corre, me voy a otro terminal a tratar de ejecutarlo de nuevo:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>./bloqueo.sh
Ya estoy contando hasta 10</code></pre></div>

<p>¿Correcto? ¡¡Pues no, muy mal!! Aquí se da lo que se conoce como <em>race condition</em>; y es que en el intervalo entre que se chequea la existencia del fichero y se crea este, es posible que otro script empiece a ejecutarse y se venga abajo todo nuestro tinglado. Claro, la operación no es atómica. ¿No crees que sea posible? Mira qué fácil:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>./bloqueo.sh <span class="p">&amp;</span> ./bloqueo.sh
<span class="o">[</span>1<span class="o">]</span> 20099
1
1
2
2
3
3
4
4</code></pre></div>

<p>Bash ofrece un mecanismo que sirve de ayuda para estos casos: la opción noclobber. Veamos qué dice man bash:</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>If the redirection operator is &gt;, and the noclobber option to the set builtin has been enabled, the redirection will fail if the file whose name results from the expansion of word exists and is a regular file. If the redirection operator is &gt;</td>
        <td>, or the redirection operator is &gt; and the noclobber option to the set builtin command is not enabled, the redirection is attempted even if the file named by word exists.</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>Vamos, que si está establecido noclobber y se usa el operador de redirección &gt;, esta fallará si el fichero existe. Probemos así entonces:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>cat bloqueo2.sh
<span class="c">#!/bin/bash</span>
<span class="nv">LOCK</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">/bloqueo.lck&quot;</span>
<span class="c"># Si no existe el fichero, lo escribo y me ejecuto:</span>
<span class="k">if</span> <span class="o">(</span> <span class="nb">set</span> -o noclobber<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$$</span><span class="s2">&quot;</span> &gt; <span class="s2">&quot;</span><span class="nv">$LOCK</span><span class="s2">&quot;</span><span class="o">)</span> 2&gt; /dev/null<span class="p">;</span> <span class="k">then</span>
 <span class="nv">i</span><span class="o">=</span>1
 <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
 <span class="nb">echo</span> <span class="nv">$i</span>
 <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
 sleep 1
 <span class="k">done</span>
 /bin/rm <span class="nv">$LOCK</span>
<span class="k">else</span>
 <span class="nb">echo</span> <span class="s2">&quot;Ya estoy contando hasta 10&quot;</span>
<span class="k">fi</span></code></pre></div>

<p>Y probando a ejecutarlo como antes:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>./bloqueo2.sh <span class="p">&amp;</span> ./bloqueo2.sh
<span class="o">[</span>1<span class="o">]</span> 20178
1
Ya estoy contando hasta 10
<span class="nv">$ </span>2
3
4
5</code></pre></div>

<p>Vemos como, efectivamente, uno de los dos scripts falla.</p>

<p>Si nos cansamos de ver cómo cuenta el script y lo interrumpimos (Ctrl+C), ¿qué es lo que ocurrirá? Que la siguiente vez que queramos lanzarlo no podremos, porque nos habremos dejado colgando el fichero de lock. Así que, poniendo en práctica lo visto en el artículo referenciado arriba, podemos hacer esto:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>cat bloqueo3.sh
<span class="c">#!/bin/bash</span>
<span class="nv">LOCK</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">/bloqueo.lck&quot;</span>
<span class="nb">trap</span> <span class="s1">&#39;rm -f &quot;$LOCK&quot;; exit&#39;</span> INT TERM EXIT ERR
<span class="c"># Si no existe el fichero, lo escribo y me ejecuto:</span>
<span class="k">if</span> <span class="o">(</span> <span class="nb">set</span> -o noclobber<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$$</span><span class="s2">&quot;</span> <span class="p">&amp;</span> <span class="s2">&quot;</span><span class="nv">$LOCK</span><span class="s2">&quot;</span><span class="o">)</span> 2&gt; /dev/null<span class="p">;</span> <span class="k">then</span>
 <span class="nv">i</span><span class="o">=</span>1
 <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
 <span class="nb">echo</span> <span class="nv">$i</span>
 <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
 sleep 1
 <span class="k">done</span>
 /bin/rm <span class="nv">$LOCK</span>
<span class="k">else</span>
 <span class="nb">echo</span> <span class="s2">&quot;Ya estoy contando hasta 10&quot;</span>
<span class="k">fi</span></code></pre></div>

<p>¿Mejor, no? ¡¡Pues no!! ¡¡Muchísimo peor!! Definiendo así el trap, un segundo script que se ejecutara no contaría, pero borraría el fichero de lock, permitiendo que se ejecutase un tercer script. La mejor alternativa sería esta:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>cat ./bloqueo2.sh
<span class="c">#!/bin/bash</span>
<span class="nv">LOCK</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">/bloqueo.lck&quot;</span>
<span class="c"># Si no existe el fichero, lo escribo y me ejecuto:</span>
<span class="k">if</span> <span class="o">(</span> <span class="nb">set</span> -o noclobber<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$$</span><span class="s2">&quot;</span> <span class="p">&amp;</span> <span class="s2">&quot;</span><span class="nv">$LOCK</span><span class="s2">&quot;</span><span class="o">)</span> 2&gt; /dev/null<span class="p">;</span> <span class="k">then</span>
 <span class="nb">trap</span> <span class="s1">&#39;rm -f &quot;$LOCK&quot;; exit&#39;</span> INT TERM EXIT ERR
 <span class="nv">i</span><span class="o">=</span>1
 <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
 <span class="nb">echo</span> <span class="nv">$i</span>
 <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
 sleep 1
 <span class="k">done</span>
 /bin/rm <span class="nv">$LOCK</span>
 <span class="nb">trap</span> - INT TERM EXIT ERR
<span class="k">else</span>
 <span class="nb">echo</span> <span class="s2">&quot;Ya estoy contando hasta 10&quot;</span>
<span class="k">fi</span></code></pre></div>

<p>De esta forma, en el momento en que el script falla aún no se han redefinido los traps y el fichero .lck no se borra.</p>

<p>Aun así, no estaría de más comprobar antes de borrar el fichero de lock que realmente ha sido escrito por mí (de ahí que se escriba el pid en el fichero). Pero bueno, eso ya es segundo de bash</p>

  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

          <!-- <h2 class="footer-heading">Out of memory</h2> -->

    <div class="footer-col-1 column">
      <ul>
        <li>Out of memory</li>
        <li><a href="mailto:"></a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        
        
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">b3V0IG9mIG1lbW9yeQ==</p>
    </div>

  </div>

</footer>


    </body>
</html>